var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"ClusterControl","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stddef.h>\n#include <stdio.h>              // This example main program uses printf/fflush\n#include \"ClusterControl.h\"            // Model header file\n\nstatic BenchTest::ClusterControl ClusterControl_Obj;// Instance of model class\n\n//\n// Associating rt_OneStep with a real-time clock or interrupt service routine\n// is what makes the generated code \"real-time\".  The function rt_OneStep is\n// always associated with the base rate of the model.  Subrates are managed\n// by the base rate from inside the generated code.  Enabling/disabling\n// interrupts and floating point context switches are target specific.  This\n// example code indicates where these should take place relative to executing\n// the generated code step function.  Overrun behavior should be tailored to\n// your application needs.  This example simply sets an error status in the\n// real-time model and returns from rt_OneStep.\n//\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  // Disable interrupts here\n\n  // Check for overrun\n  if (OverrunFlag) {\n    rtmSetErrorStatus(ClusterControl_Obj.getRTM(), \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  // Save FPU context here (if necessary)\n  // Re-enable timer or interrupt here\n  // Set model inputs here\n\n  // Step the model\n  ClusterControl_Obj.Model_Step_100Hz();\n\n  // Get model outputs here\n\n  // Indicate task complete\n  OverrunFlag = false;\n\n  // Disable interrupts here\n  // Restore FPU context here (if necessary)\n  // Enable interrupts here\n}\n\n//\n// The example main function illustrates what is required by your\n// application code to initialize, execute, and terminate the generated code.\n// Attaching rt_OneStep to a real-time clock is target specific. This example\n// illustrates how you do this relative to initializing the model.\n//\nint_T main(int_T argc, const char *argv[])\n{\n  // Unused arguments\n  (void)(argc);\n  (void)(argv);\n\n  // Initialize model\n  ClusterControl_Obj.Initialize();\n\n  // Attach rt_OneStep to a timer or interrupt service routine with\n  //  period 0.01 seconds (base rate of the model) here.\n  //  The call syntax for rt_OneStep is\n  //\n  //   rt_OneStep();\n\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(ClusterControl_Obj.getRTM()) == (NULL)) {\n    //  Perform application tasks here\n  }\n\n  // Terminate model\n  ClusterControl_Obj.Terminate();\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl.cpp","type":"source","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"ClusterControl.h\"\n#include \"rtwtypes.h\"\n#include \"ClusterControl_private.h\"\n\nconst real_T ClusterControl_period = 0.01;\nnamespace BenchTest\n{\n  // Model step function\n  void ClusterControl::Model_Step_100Hz()\n  {\n    real_T rateLimiterRate;\n\n    // Outputs for Atomic SubSystem: '<Root>/Model_Step100 '\n    // RateLimiter: '<S2>/Rate Limiter' incorporates:\n    //   Inport: '<Root>/Fuel_In'\n    //   Outport: '<Root>/Fuel_Out'\n\n    rateLimiterRate = ClusterControl_U.FuelPc_In - ClusterControl_DW.PrevY;\n    if (rateLimiterRate > ClusterControl_P.RateLimiter_RisingLim *\n        ClusterControl_period) {\n      ClusterControl_Y.Fuel_Out = ClusterControl_P.RateLimiter_RisingLim *\n        ClusterControl_period + ClusterControl_DW.PrevY;\n    } else if (rateLimiterRate < ClusterControl_P.RateLimiter_FallingLim *\n               ClusterControl_period) {\n      ClusterControl_Y.Fuel_Out = ClusterControl_P.RateLimiter_FallingLim *\n        ClusterControl_period + ClusterControl_DW.PrevY;\n    } else {\n      ClusterControl_Y.Fuel_Out = ClusterControl_U.FuelPc_In;\n    }\n\n    ClusterControl_DW.PrevY = ClusterControl_Y.Fuel_Out;\n\n    // End of RateLimiter: '<S2>/Rate Limiter'\n\n    // RateLimiter: '<S2>/Rate Limiter1' incorporates:\n    //   Inport: '<Root>/Coolant_Temp_In'\n    //   Outport: '<Root>/Coolant_Temp_Out'\n\n    rateLimiterRate = ClusterControl_U.Coolant_Temp_In -\n      ClusterControl_DW.PrevY_n;\n    if (rateLimiterRate > ClusterControl_P.RateLimiter1_RisingLim *\n        ClusterControl_period) {\n      ClusterControl_Y.Coolant_Temp_Out =\n        ClusterControl_P.RateLimiter1_RisingLim * ClusterControl_period +\n        ClusterControl_DW.PrevY_n;\n    } else if (rateLimiterRate < ClusterControl_P.RateLimiter1_FallingLim *\n               ClusterControl_period) {\n      ClusterControl_Y.Coolant_Temp_Out =\n        ClusterControl_P.RateLimiter1_FallingLim * ClusterControl_period +\n        ClusterControl_DW.PrevY_n;\n    } else {\n      ClusterControl_Y.Coolant_Temp_Out = ClusterControl_U.Coolant_Temp_In;\n    }\n\n    ClusterControl_DW.PrevY_n = ClusterControl_Y.Coolant_Temp_Out;\n\n    // End of RateLimiter: '<S2>/Rate Limiter1'\n\n    // RateLimiter: '<S2>/Rate Limiter2' incorporates:\n    //   Inport: '<Root>/Batt_V_In'\n    //   Outport: '<Root>/Batt_V_Out'\n\n    rateLimiterRate = ClusterControl_U.Batt_V_In - ClusterControl_DW.PrevY_a;\n    if (rateLimiterRate > ClusterControl_P.RateLimiter2_RisingLim *\n        ClusterControl_period) {\n      ClusterControl_Y.Batt_V_Out = ClusterControl_P.RateLimiter2_RisingLim *\n        ClusterControl_period + ClusterControl_DW.PrevY_a;\n    } else if (rateLimiterRate < ClusterControl_P.RateLimiter2_FallingLim *\n               ClusterControl_period) {\n      ClusterControl_Y.Batt_V_Out = ClusterControl_P.RateLimiter2_FallingLim *\n        ClusterControl_period + ClusterControl_DW.PrevY_a;\n    } else {\n      ClusterControl_Y.Batt_V_Out = ClusterControl_U.Batt_V_In;\n    }\n\n    ClusterControl_DW.PrevY_a = ClusterControl_Y.Batt_V_Out;\n\n    // End of RateLimiter: '<S2>/Rate Limiter2'\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF'\n    // DiscreteIntegrator: '<S4>/X''\n    ClusterControl_B.Velocity_b = ClusterControl_DW.X_DSTATE_l;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF'\n    // Product: '<S4>/Cx''\n    ClusterControl_B.Cx_h = ClusterControl_B.Velocity_b *\n      ClusterControl_P.SDOF_DampingConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF'\n\n    // Outport: '<Root>/RPM_Out' incorporates:\n    //   DiscreteIntegrator: '<S4>/X'\n\n    ClusterControl_Y.RPM_Out = ClusterControl_DW.X_DSTATE_i;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF'\n    // Product: '<S4>/Kx' incorporates:\n    //   Outport: '<Root>/RPM_Out'\n\n    ClusterControl_B.Kx_f = ClusterControl_Y.RPM_Out *\n      ClusterControl_P.SDOF_SpringConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF'\n\n    // WeightedSampleTime: '<S6>/TSamp' incorporates:\n    //   Inport: '<Root>/RPM_In'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n\n    ClusterControl_B.TSamp_i = ClusterControl_U.RPM_In;\n\n    // UnitDelay: '<S6>/UD'\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_B.Uk1_p = ClusterControl_DW.UD_DSTATE_e;\n\n    // Sum: '<S6>/Diff' incorporates:\n    //   UnitDelay: '<S6>/UD'\n    //   WeightedSampleTime: '<S6>/TSamp'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n    //\n    //  Block description for '<S6>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_B.Diff_h = ClusterControl_B.TSamp_i - ClusterControl_B.Uk1_p;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF'\n    // Product: '<S4>/Cu'' incorporates:\n    //   Sum: '<S6>/Diff'\n    //\n    //  Block description for '<S6>/Diff':\n    //\n    //   Add in CPU\n\n    ClusterControl_B.Cu_p = static_cast<real_T>(ClusterControl_B.Diff_h) * 100.0\n      * ClusterControl_P.SDOF_DampingConstant;\n\n    // Product: '<S4>/Ku' incorporates:\n    //   Inport: '<Root>/RPM_In'\n\n    ClusterControl_B.Ku_j = static_cast<real_T>(ClusterControl_U.RPM_In) *\n      ClusterControl_P.SDOF_SpringConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF'\n\n    // Sum: '<S4>/Add'\n    ClusterControl_B.Add_e = ((ClusterControl_B.Cu_p - ClusterControl_B.Cx_h) -\n      ClusterControl_B.Kx_f) + ClusterControl_B.Ku_j;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF'\n    // Product: '<S4>/Divide'\n    ClusterControl_B.Acceleration_j = ClusterControl_B.Add_e /\n      ClusterControl_P.SDOF_MassConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF'\n\n    // Update for DiscreteIntegrator: '<S4>/X''\n    ClusterControl_DW.X_DSTATE_l += ClusterControl_P.X_gainval *\n      ClusterControl_B.Acceleration_j;\n\n    // Update for DiscreteIntegrator: '<S4>/X'\n    ClusterControl_DW.X_DSTATE_i += ClusterControl_P.X_gainval_l *\n      ClusterControl_B.Velocity_b;\n\n    // Update for UnitDelay: '<S6>/UD' incorporates:\n    //   WeightedSampleTime: '<S6>/TSamp'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE_e = ClusterControl_B.TSamp_i;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF'\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF1'\n    // DiscreteIntegrator: '<S5>/X''\n    ClusterControl_B.Velocity = ClusterControl_DW.X_DSTATE;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF1'\n    // Product: '<S5>/Cx''\n    ClusterControl_B.Cx = ClusterControl_B.Velocity *\n      ClusterControl_P.SDOF1_DampingConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF1'\n\n    // Outport: '<Root>/Speed_Out' incorporates:\n    //   DiscreteIntegrator: '<S5>/X'\n\n    ClusterControl_Y.Speed_Out = ClusterControl_DW.X_DSTATE_h;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF1'\n    // Product: '<S5>/Kx' incorporates:\n    //   Outport: '<Root>/Speed_Out'\n\n    ClusterControl_B.Kx = ClusterControl_Y.Speed_Out *\n      ClusterControl_P.SDOF1_SpringConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF1'\n\n    // WeightedSampleTime: '<S7>/TSamp' incorporates:\n    //   Inport: '<Root>/Speed_In'\n    //\n    //  About '<S7>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n\n    ClusterControl_B.TSamp = ClusterControl_U.Speed_In *\n      ClusterControl_P.TSamp_WtEt;\n\n    // UnitDelay: '<S7>/UD'\n    //\n    //  Block description for '<S7>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_B.Uk1 = ClusterControl_DW.UD_DSTATE;\n\n    // Sum: '<S7>/Diff'\n    //\n    //  Block description for '<S7>/Diff':\n    //\n    //   Add in CPU\n\n    ClusterControl_B.Diff = ClusterControl_B.TSamp - ClusterControl_B.Uk1;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF1'\n    // Product: '<S5>/Cu''\n    ClusterControl_B.Cu = ClusterControl_B.Diff *\n      ClusterControl_P.SDOF1_DampingConstant;\n\n    // Product: '<S5>/Ku' incorporates:\n    //   Inport: '<Root>/Speed_In'\n\n    ClusterControl_B.Ku = ClusterControl_U.Speed_In *\n      ClusterControl_P.SDOF1_SpringConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF1'\n\n    // Sum: '<S5>/Add'\n    ClusterControl_B.Add = ((ClusterControl_B.Cu - ClusterControl_B.Cx) -\n      ClusterControl_B.Kx) + ClusterControl_B.Ku;\n\n    // Outputs for Atomic SubSystem: '<S2>/SDOF1'\n    // Product: '<S5>/Divide'\n    ClusterControl_B.Acceleration = ClusterControl_B.Add /\n      ClusterControl_P.SDOF1_MassConstant;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF1'\n\n    // Update for DiscreteIntegrator: '<S5>/X''\n    ClusterControl_DW.X_DSTATE += ClusterControl_P.X_gainval_n *\n      ClusterControl_B.Acceleration;\n\n    // Update for DiscreteIntegrator: '<S5>/X'\n    ClusterControl_DW.X_DSTATE_h += ClusterControl_P.X_gainval_h *\n      ClusterControl_B.Velocity;\n\n    // Update for UnitDelay: '<S7>/UD'\n    //\n    //  Block description for '<S7>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE = ClusterControl_B.TSamp;\n\n    // End of Outputs for SubSystem: '<S2>/SDOF1'\n    // End of Outputs for SubSystem: '<Root>/Model_Step100 '\n  }\n\n  // Model initialize function\n  void ClusterControl::Initialize()\n  {\n    // SystemInitialize for Atomic SubSystem: '<Root>/Model_Step100 '\n    // InitializeConditions for RateLimiter: '<S2>/Rate Limiter'\n    ClusterControl_DW.PrevY = ClusterControl_P.RateLimiter_IC;\n\n    // InitializeConditions for RateLimiter: '<S2>/Rate Limiter1'\n    ClusterControl_DW.PrevY_n = ClusterControl_P.RateLimiter1_IC;\n\n    // InitializeConditions for RateLimiter: '<S2>/Rate Limiter2'\n    ClusterControl_DW.PrevY_a = ClusterControl_P.RateLimiter2_IC;\n\n    // SystemInitialize for Atomic SubSystem: '<S2>/SDOF'\n    // InitializeConditions for DiscreteIntegrator: '<S4>/X''\n    ClusterControl_DW.X_DSTATE_l = ClusterControl_P.X_IC;\n\n    // InitializeConditions for DiscreteIntegrator: '<S4>/X'\n    ClusterControl_DW.X_DSTATE_i = ClusterControl_P.X_IC_a;\n\n    // InitializeConditions for UnitDelay: '<S6>/UD'\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE_e =\n      ClusterControl_P.DiscreteDerivative_ICPrevScal_d;\n\n    // End of SystemInitialize for SubSystem: '<S2>/SDOF'\n\n    // SystemInitialize for Atomic SubSystem: '<S2>/SDOF1'\n    // InitializeConditions for DiscreteIntegrator: '<S5>/X''\n    ClusterControl_DW.X_DSTATE = ClusterControl_P.X_IC_o;\n\n    // InitializeConditions for DiscreteIntegrator: '<S5>/X'\n    ClusterControl_DW.X_DSTATE_h = ClusterControl_P.X_IC_p;\n\n    // InitializeConditions for UnitDelay: '<S7>/UD'\n    //\n    //  Block description for '<S7>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE =\n      ClusterControl_P.DiscreteDerivative_ICPrevScaled;\n\n    // End of SystemInitialize for SubSystem: '<S2>/SDOF1'\n    // End of SystemInitialize for SubSystem: '<Root>/Model_Step100 '\n  }\n\n  // Model terminate function\n  void ClusterControl::Terminate()\n  {\n    // (no terminate code required)\n  }\n\n  // Root inport: '<Root>/RPM_In' set method\n  void ClusterControl::setRPM_In(int32_T localArgInput)\n  {\n    ClusterControl_U.RPM_In = localArgInput;\n  }\n\n  // Root inport: '<Root>/Speed_In' set method\n  void ClusterControl::setSpeed_In(real_T localArgInput)\n  {\n    ClusterControl_U.Speed_In = localArgInput;\n  }\n\n  // Root inport: '<Root>/Fuel_In' set method\n  void ClusterControl::setFuel_In(real_T localArgInput)\n  {\n    ClusterControl_U.FuelPc_In = localArgInput;\n  }\n\n  // Root inport: '<Root>/Coolant_Temp_In' set method\n  void ClusterControl::setCoolant_Temp_In(real_T localArgInput)\n  {\n    ClusterControl_U.Coolant_Temp_In = localArgInput;\n  }\n\n  // Root inport: '<Root>/Batt_V_In' set method\n  void ClusterControl::setBatt_V_In(real_T localArgInput)\n  {\n    ClusterControl_U.Batt_V_In = localArgInput;\n  }\n\n  // Root outport: '<Root>/RPM_Out' get method\n  real_T ClusterControl::getRPM_Out() const\n  {\n    return ClusterControl_Y.RPM_Out;\n  }\n\n  // Root outport: '<Root>/Speed_Out' get method\n  real_T ClusterControl::getSpeed_Out() const\n  {\n    return ClusterControl_Y.Speed_Out;\n  }\n\n  // Root outport: '<Root>/Fuel_Out' get method\n  real_T ClusterControl::getFuel_Out() const\n  {\n    return ClusterControl_Y.Fuel_Out;\n  }\n\n  // Root outport: '<Root>/Coolant_Temp_Out' get method\n  real_T ClusterControl::getCoolant_Temp_Out() const\n  {\n    return ClusterControl_Y.Coolant_Temp_Out;\n  }\n\n  // Root outport: '<Root>/Batt_V_Out' get method\n  real_T ClusterControl::getBatt_V_Out() const\n  {\n    return ClusterControl_Y.Batt_V_Out;\n  }\n\n  // Constructor\n  ClusterControl::ClusterControl() :\n    ClusterControl_U(),\n    ClusterControl_Y(),\n    ClusterControl_B(),\n    ClusterControl_DW(),\n    ClusterControl_M()\n  {\n    // Currently there is no constructor body generated.\n  }\n\n  // Destructor\n  ClusterControl::~ClusterControl()\n  {\n    // Currently there is no destructor body generated.\n  }\n\n  // Real-Time Model get method\n  ClusterControl::RT_MODEL_ClusterControl_T * ClusterControl::getRTM()\n  {\n    return (&ClusterControl_M);\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_h_\n#define RTW_HEADER_ClusterControl_h_\n#include \"rtwtypes.h\"\n#include \"ClusterControl_types.h\"\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n// Code_Instrumentation_Declarations_Placeholder\n\n// Class declaration for model ClusterControl\nnamespace BenchTest\n{\n  class ClusterControl\n  {\n    // public data and function members\n   public:\n    // Block signals (default storage)\n    struct B_ClusterControl_T {\n      real_T Velocity;                 // '<S5>/X''\n      real_T Cx;                       // '<S5>/Cx''\n      real_T Kx;                       // '<S5>/Kx'\n      real_T TSamp;                    // '<S7>/TSamp'\n      real_T Uk1;                      // '<S7>/UD'\n      real_T Diff;                     // '<S7>/Diff'\n      real_T Cu;                       // '<S5>/Cu''\n      real_T Ku;                       // '<S5>/Ku'\n      real_T Add;                      // '<S5>/Add'\n      real_T Acceleration;             // '<S5>/Divide'\n      real_T Velocity_b;               // '<S4>/X''\n      real_T Cx_h;                     // '<S4>/Cx''\n      real_T Kx_f;                     // '<S4>/Kx'\n      real_T Cu_p;                     // '<S4>/Cu''\n      real_T Ku_j;                     // '<S4>/Ku'\n      real_T Add_e;                    // '<S4>/Add'\n      real_T Acceleration_j;           // '<S4>/Divide'\n      int32_T TSamp_i;                 // '<S6>/TSamp'\n      int32_T Uk1_p;                   // '<S6>/UD'\n      int32_T Diff_h;                  // '<S6>/Diff'\n    };\n\n    // Block states (default storage) for system '<Root>'\n    struct DW_ClusterControl_T {\n      real_T X_DSTATE;                 // '<S5>/X''\n      real_T X_DSTATE_h;               // '<S5>/X'\n      real_T UD_DSTATE;                // '<S7>/UD'\n      real_T X_DSTATE_l;               // '<S4>/X''\n      real_T X_DSTATE_i;               // '<S4>/X'\n      real_T PrevY;                    // '<S2>/Rate Limiter'\n      real_T PrevY_n;                  // '<S2>/Rate Limiter1'\n      real_T PrevY_a;                  // '<S2>/Rate Limiter2'\n      int32_T UD_DSTATE_e;             // '<S6>/UD'\n      int32_T Diff_DWORK1;             // '<S6>/Diff'\n    };\n\n    // External inputs (root inport signals with default storage)\n    struct ExtU_ClusterControl_T {\n      int32_T RPM_In;                  // '<Root>/RPM_In'\n      real_T Speed_In;                 // '<Root>/Speed_In'\n      real_T FuelPc_In;                // '<Root>/Fuel_In'\n      real_T Coolant_Temp_In;          // '<Root>/Coolant_Temp_In'\n      real_T Batt_V_In;                // '<Root>/Batt_V_In'\n    };\n\n    // External outputs (root outports fed by signals with default storage)\n    struct ExtY_ClusterControl_T {\n      real_T RPM_Out;                  // '<Root>/RPM_Out'\n      real_T Speed_Out;                // '<Root>/Speed_Out'\n      real_T Fuel_Out;                 // '<Root>/Fuel_Out'\n      real_T Coolant_Temp_Out;         // '<Root>/Coolant_Temp_Out'\n      real_T Batt_V_Out;               // '<Root>/Batt_V_Out'\n    };\n\n    // Parameters (default storage)\n    struct P_ClusterControl_T {\n      real_T SDOF_DampingConstant;     // Mask Parameter: SDOF_DampingConstant\n                                          //  Referenced by: '<S4>/C'\n\n      real_T SDOF1_DampingConstant;    // Mask Parameter: SDOF1_DampingConstant\n                                          //  Referenced by: '<S5>/C'\n\n      real_T DiscreteDerivative_ICPrevScaled;\n                              // Mask Parameter: DiscreteDerivative_ICPrevScaled\n                                 //  Referenced by: '<S7>/UD'\n\n      real_T SDOF_MassConstant;        // Mask Parameter: SDOF_MassConstant\n                                          //  Referenced by: '<S4>/m'\n\n      real_T SDOF1_MassConstant;       // Mask Parameter: SDOF1_MassConstant\n                                          //  Referenced by: '<S5>/m'\n\n      real_T SDOF_SpringConstant;      // Mask Parameter: SDOF_SpringConstant\n                                          //  Referenced by: '<S4>/K'\n\n      real_T SDOF1_SpringConstant;     // Mask Parameter: SDOF1_SpringConstant\n                                          //  Referenced by: '<S5>/K'\n\n      int32_T DiscreteDerivative_ICPrevScal_d;\n                              // Mask Parameter: DiscreteDerivative_ICPrevScal_d\n                                 //  Referenced by: '<S6>/UD'\n\n      real_T X_gainval;                // Computed Parameter: X_gainval\n                                          //  Referenced by: '<S4>/X''\n\n      real_T X_IC;                     // Expression: 0\n                                          //  Referenced by: '<S4>/X''\n\n      real_T X_gainval_l;              // Computed Parameter: X_gainval_l\n                                          //  Referenced by: '<S4>/X'\n\n      real_T X_IC_a;                   // Expression: 0\n                                          //  Referenced by: '<S4>/X'\n\n      real_T X_gainval_n;              // Computed Parameter: X_gainval_n\n                                          //  Referenced by: '<S5>/X''\n\n      real_T X_IC_o;                   // Expression: 0\n                                          //  Referenced by: '<S5>/X''\n\n      real_T X_gainval_h;              // Computed Parameter: X_gainval_h\n                                          //  Referenced by: '<S5>/X'\n\n      real_T X_IC_p;                   // Expression: 0\n                                          //  Referenced by: '<S5>/X'\n\n      real_T TSamp_WtEt;               // Computed Parameter: TSamp_WtEt\n                                          //  Referenced by: '<S7>/TSamp'\n\n      real_T RateLimiter_RisingLim;    // Expression: 1\n                                          //  Referenced by: '<S2>/Rate Limiter'\n\n      real_T RateLimiter_FallingLim;   // Expression: -1\n                                          //  Referenced by: '<S2>/Rate Limiter'\n\n      real_T RateLimiter_IC;           // Expression: 0\n                                          //  Referenced by: '<S2>/Rate Limiter'\n\n      real_T RateLimiter1_RisingLim;   // Expression: 5\n                                          //  Referenced by: '<S2>/Rate Limiter1'\n\n      real_T RateLimiter1_FallingLim;  // Expression: -5\n                                          //  Referenced by: '<S2>/Rate Limiter1'\n\n      real_T RateLimiter1_IC;          // Expression: 0\n                                          //  Referenced by: '<S2>/Rate Limiter1'\n\n      real_T RateLimiter2_RisingLim;   // Expression: 5\n                                          //  Referenced by: '<S2>/Rate Limiter2'\n\n      real_T RateLimiter2_FallingLim;  // Expression: -5\n                                          //  Referenced by: '<S2>/Rate Limiter2'\n\n      real_T RateLimiter2_IC;          // Expression: 0\n                                          //  Referenced by: '<S2>/Rate Limiter2'\n\n    };\n\n    // Real-time Model Data Structure\n    struct RT_MODEL_ClusterControl_T {\n      const char_T * volatile errorStatus;\n    };\n\n    // Real-Time Model get method\n    ClusterControl::RT_MODEL_ClusterControl_T * getRTM();\n\n    // External inputs\n    ExtU_ClusterControl_T ClusterControl_U;\n\n    // External outputs\n    ExtY_ClusterControl_T ClusterControl_Y;\n\n    // Root inport: '<Root>/RPM_In' set method\n    void setRPM_In(int32_T localArgInput);\n\n    // Root inport: '<Root>/Speed_In' set method\n    void setSpeed_In(real_T localArgInput);\n\n    // Root inport: '<Root>/Fuel_In' set method\n    void setFuel_In(real_T localArgInput);\n\n    // Root inport: '<Root>/Coolant_Temp_In' set method\n    void setCoolant_Temp_In(real_T localArgInput);\n\n    // Root inport: '<Root>/Batt_V_In' set method\n    void setBatt_V_In(real_T localArgInput);\n\n    // Root outport: '<Root>/RPM_Out' get method\n    real_T getRPM_Out() const;\n\n    // Root outport: '<Root>/Speed_Out' get method\n    real_T getSpeed_Out() const;\n\n    // Root outport: '<Root>/Fuel_Out' get method\n    real_T getFuel_Out() const;\n\n    // Root outport: '<Root>/Coolant_Temp_Out' get method\n    real_T getCoolant_Temp_Out() const;\n\n    // Root outport: '<Root>/Batt_V_Out' get method\n    real_T getBatt_V_Out() const;\n\n    // model initialize function\n    void Initialize();\n\n    // model step function\n    void Model_Step_100Hz();\n\n    // model terminate function\n    static void Terminate();\n\n    // Constructor\n    ClusterControl();\n\n    // Destructor\n    ~ClusterControl();\n\n    // private data and function members\n   private:\n    // Block signals\n    B_ClusterControl_T ClusterControl_B;\n\n    // Block states\n    DW_ClusterControl_T ClusterControl_DW;\n\n    // Tunable parameters\n    static P_ClusterControl_T ClusterControl_P;\n\n    // Real-Time Model\n    RT_MODEL_ClusterControl_T ClusterControl_M;\n  };\n}\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S6>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S7>/Data Type Duplicate' : Unused code path elimination\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'ClusterControl'\n//  '<S1>'   : 'ClusterControl/Initialize Function'\n//  '<S2>'   : 'ClusterControl/Model_Step100 '\n//  '<S3>'   : 'ClusterControl/Terminate Function'\n//  '<S4>'   : 'ClusterControl/Model_Step100 /SDOF'\n//  '<S5>'   : 'ClusterControl/Model_Step100 /SDOF1'\n//  '<S6>'   : 'ClusterControl/Model_Step100 /SDOF/Discrete Derivative'\n//  '<S7>'   : 'ClusterControl/Model_Step100 /SDOF1/Discrete Derivative'\n\n#endif                                 // RTW_HEADER_ClusterControl_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_private.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_private.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_private_h_\n#define RTW_HEADER_ClusterControl_private_h_\n#include \"rtwtypes.h\"\n#include \"ClusterControl_types.h\"\n#ifndef UCHAR_MAX\n#include <limits.h>\n#endif\n\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\n#error Code was generated for compiler with different sized uchar/char. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\n#error Code was generated for compiler with different sized ushort/short. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized uint/int. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n// Skipping ulong/long check: insufficient preprocessor integer range.\n\n// Skipping ulong_long/long_long check: insufficient preprocessor integer range. \n#endif                                 // RTW_HEADER_ClusterControl_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_types.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_types.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_types_h_\n#define RTW_HEADER_ClusterControl_types_h_\n#endif                                 // RTW_HEADER_ClusterControl_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_data.cpp","type":"source","group":"data","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_data.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.23\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Mon Sep 18 15:23:57 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"ClusterControl.h\"\n\n// Block parameters (default storage)\nBenchTest::ClusterControl::P_ClusterControl_T BenchTest::ClusterControl::\n  ClusterControl_P = {\n  // Mask Parameter: SDOF_DampingConstant\n  //  Referenced by: '<S4>/C'\n\n  3.0,\n\n  // Mask Parameter: SDOF1_DampingConstant\n  //  Referenced by: '<S5>/C'\n\n  3.0,\n\n  // Mask Parameter: DiscreteDerivative_ICPrevScaled\n  //  Referenced by: '<S7>/UD'\n\n  0.0,\n\n  // Mask Parameter: SDOF_MassConstant\n  //  Referenced by: '<S4>/m'\n\n  0.3,\n\n  // Mask Parameter: SDOF1_MassConstant\n  //  Referenced by: '<S5>/m'\n\n  0.3,\n\n  // Mask Parameter: SDOF_SpringConstant\n  //  Referenced by: '<S4>/K'\n\n  20.0,\n\n  // Mask Parameter: SDOF1_SpringConstant\n  //  Referenced by: '<S5>/K'\n\n  20.0,\n\n  // Mask Parameter: DiscreteDerivative_ICPrevScal_d\n  //  Referenced by: '<S6>/UD'\n\n  0,\n\n  // Computed Parameter: X_gainval\n  //  Referenced by: '<S4>/X''\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S4>/X''\n\n  0.0,\n\n  // Computed Parameter: X_gainval_l\n  //  Referenced by: '<S4>/X'\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S4>/X'\n\n  0.0,\n\n  // Computed Parameter: X_gainval_n\n  //  Referenced by: '<S5>/X''\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S5>/X''\n\n  0.0,\n\n  // Computed Parameter: X_gainval_h\n  //  Referenced by: '<S5>/X'\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S5>/X'\n\n  0.0,\n\n  // Computed Parameter: TSamp_WtEt\n  //  Referenced by: '<S7>/TSamp'\n\n  100.0,\n\n  // Expression: 1\n  //  Referenced by: '<S2>/Rate Limiter'\n\n  1.0,\n\n  // Expression: -1\n  //  Referenced by: '<S2>/Rate Limiter'\n\n  -1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S2>/Rate Limiter'\n\n  0.0,\n\n  // Expression: 5\n  //  Referenced by: '<S2>/Rate Limiter1'\n\n  5.0,\n\n  // Expression: -5\n  //  Referenced by: '<S2>/Rate Limiter1'\n\n  -5.0,\n\n  // Expression: 0\n  //  Referenced by: '<S2>/Rate Limiter1'\n\n  0.0,\n\n  // Expression: 5\n  //  Referenced by: '<S2>/Rate Limiter2'\n\n  5.0,\n\n  // Expression: -5\n  //  Referenced by: '<S2>/Rate Limiter2'\n\n  -5.0,\n\n  // Expression: 0\n  //  Referenced by: '<S2>/Rate Limiter2'\n\n  0.0\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/slprj/ert/_sharedutils","tag":"","groupDisplay":"Shared files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.1\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Tue Aug 22 21:10:09 2023\n//\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: ARM Compatible->ARM Cortex-A (64-bit)\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  64    long long:  64\n//                        native word size:  64\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};