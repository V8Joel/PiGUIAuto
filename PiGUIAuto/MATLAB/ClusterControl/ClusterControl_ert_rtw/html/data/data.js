var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"ClusterControl","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stddef.h>\n#include <stdio.h>              // This example main program uses printf/fflush\n#include \"ClusterControl.h\"            // Model header file\n\nstatic BenchTest::ClusterControl ClusterControl_Obj;// Instance of model class\n\n//\n// Associating rt_OneStep with a real-time clock or interrupt service routine\n// is what makes the generated code \"real-time\".  The function rt_OneStep is\n// always associated with the base rate of the model.  Subrates are managed\n// by the base rate from inside the generated code.  Enabling/disabling\n// interrupts and floating point context switches are target specific.  This\n// example code indicates where these should take place relative to executing\n// the generated code step function.  Overrun behavior should be tailored to\n// your application needs.  This example simply sets an error status in the\n// real-time model and returns from rt_OneStep.\n//\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  // Disable interrupts here\n\n  // Check for overrun\n  if (OverrunFlag) {\n    rtmSetErrorStatus(ClusterControl_Obj.getRTM(), \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  // Save FPU context here (if necessary)\n  // Re-enable timer or interrupt here\n  // Set model inputs here\n\n  // Step the model\n  ClusterControl_Obj.Model_Step_100Hz();\n\n  // Get model outputs here\n\n  // Indicate task complete\n  OverrunFlag = false;\n\n  // Disable interrupts here\n  // Restore FPU context here (if necessary)\n  // Enable interrupts here\n}\n\n//\n// The example main function illustrates what is required by your\n// application code to initialize, execute, and terminate the generated code.\n// Attaching rt_OneStep to a real-time clock is target specific. This example\n// illustrates how you do this relative to initializing the model.\n//\nint_T main(int_T argc, const char *argv[])\n{\n  // Unused arguments\n  (void)(argc);\n  (void)(argv);\n\n  // Initialize model\n  ClusterControl_Obj.Initialize();\n\n  // Attach rt_OneStep to a timer or interrupt service routine with\n  //  period 0.01 seconds (base rate of the model) here.\n  //  The call syntax for rt_OneStep is\n  //\n  //   rt_OneStep();\n\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(ClusterControl_Obj.getRTM()) == (NULL)) {\n    //  Perform application tasks here\n  }\n\n  // Terminate model\n  ClusterControl_Obj.Terminate();\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl.cpp","type":"source","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"ClusterControl.h\"\n#include \"rtwtypes.h\"\n#include \"ClusterControl_private.h\"\n\nnamespace BenchTest\n{\n  // Output and update for Simulink Function: '<Root>/Model_Step10'\n  void ClusterControl::Model_Step_10Hz()\n  {\n  }\n}\n\nnamespace BenchTest\n{\n  // Model step function\n  void ClusterControl::Model_Step_100Hz()\n  {\n    // Outputs for Atomic SubSystem: '<Root>/Model_Step100'\n    // Outputs for Atomic SubSystem: '<S3>/SDOF'\n    // DiscreteIntegrator: '<S5>/X''\n    ClusterControl_B.Velocity = ClusterControl_DW.X_DSTATE;\n\n    // Product: '<S5>/Cx'' incorporates:\n    //   Constant: '<S5>/C'\n\n    ClusterControl_B.Cx = ClusterControl_B.Velocity * ClusterControl_P.C_Value;\n\n    // Outport: '<Root>/RPM_Out' incorporates:\n    //   DiscreteIntegrator: '<S5>/X'\n\n    ClusterControl_Y.RPM_Out = ClusterControl_DW.X_DSTATE_c;\n\n    // Product: '<S5>/Kx' incorporates:\n    //   Constant: '<S5>/K'\n    //   Outport: '<Root>/RPM_Out'\n\n    ClusterControl_B.Kx = ClusterControl_Y.RPM_Out * ClusterControl_P.K_Value;\n\n    // WeightedSampleTime: '<S6>/TSamp' incorporates:\n    //   Inport: '<Root>/RPM_In'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n\n    ClusterControl_B.TSamp = ClusterControl_U.RPM_In;\n\n    // UnitDelay: '<S6>/UD'\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_B.Uk1 = ClusterControl_DW.UD_DSTATE;\n\n    // Sum: '<S6>/Diff' incorporates:\n    //   UnitDelay: '<S6>/UD'\n    //   WeightedSampleTime: '<S6>/TSamp'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n    //\n    //  Block description for '<S6>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_B.Diff = ClusterControl_B.TSamp - ClusterControl_B.Uk1;\n\n    // Product: '<S5>/Cu'' incorporates:\n    //   Constant: '<S5>/C'\n    //   Sum: '<S6>/Diff'\n    //\n    //  Block description for '<S6>/Diff':\n    //\n    //   Add in CPU\n\n    ClusterControl_B.Cu = static_cast<real_T>(ClusterControl_B.Diff) * 100.0 *\n      ClusterControl_P.C_Value;\n\n    // Product: '<S5>/Ku' incorporates:\n    //   Constant: '<S5>/K'\n    //   Inport: '<Root>/RPM_In'\n\n    ClusterControl_B.Ku = static_cast<real_T>(ClusterControl_U.RPM_In) *\n      ClusterControl_P.K_Value;\n\n    // Sum: '<S5>/Add'\n    ClusterControl_B.Add = ((ClusterControl_B.Cu - ClusterControl_B.Cx) -\n      ClusterControl_B.Kx) + ClusterControl_B.Ku;\n\n    // Product: '<S5>/Divide' incorporates:\n    //   Constant: '<S5>/m'\n\n    ClusterControl_B.Acceleration = ClusterControl_B.Add /\n      ClusterControl_P.m_Value;\n\n    // Update for DiscreteIntegrator: '<S5>/X''\n    ClusterControl_DW.X_DSTATE += ClusterControl_P.X_gainval *\n      ClusterControl_B.Acceleration;\n\n    // Update for DiscreteIntegrator: '<S5>/X'\n    ClusterControl_DW.X_DSTATE_c += ClusterControl_P.X_gainval_k *\n      ClusterControl_B.Velocity;\n\n    // Update for UnitDelay: '<S6>/UD' incorporates:\n    //   WeightedSampleTime: '<S6>/TSamp'\n    //\n    //  About '<S6>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //   Multiplication by K = weightedTsampQuantized is being\n    //   done implicitly by changing the scaling of the input signal.\n    //   No work needs to be done here.  Downstream blocks may need\n    //   to do work to handle the scaling of the output; this happens\n    //   automatically.\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE = ClusterControl_B.TSamp;\n\n    // End of Outputs for SubSystem: '<S3>/SDOF'\n    // End of Outputs for SubSystem: '<Root>/Model_Step100'\n  }\n\n  // Model initialize function\n  void ClusterControl::Initialize()\n  {\n    // SystemInitialize for Atomic SubSystem: '<Root>/Model_Step100'\n    // SystemInitialize for Atomic SubSystem: '<S3>/SDOF'\n    // InitializeConditions for DiscreteIntegrator: '<S5>/X''\n    ClusterControl_DW.X_DSTATE = ClusterControl_P.X_IC;\n\n    // InitializeConditions for DiscreteIntegrator: '<S5>/X'\n    ClusterControl_DW.X_DSTATE_c = ClusterControl_P.X_IC_g;\n\n    // InitializeConditions for UnitDelay: '<S6>/UD'\n    //\n    //  Block description for '<S6>/UD':\n    //\n    //   Store in Global RAM\n\n    ClusterControl_DW.UD_DSTATE =\n      ClusterControl_P.DiscreteDerivative_ICPrevScaled;\n\n    // End of SystemInitialize for SubSystem: '<S3>/SDOF'\n    // End of SystemInitialize for SubSystem: '<Root>/Model_Step100'\n  }\n\n  // Model terminate function\n  void ClusterControl::Terminate()\n  {\n    // (no terminate code required)\n  }\n\n  // Root inport: '<Root>/RPM_In' set method\n  void ClusterControl::setRPM_In(int32_T localArgInput)\n  {\n    ClusterControl_U.RPM_In = localArgInput;\n  }\n\n  // Root outport: '<Root>/RPM_Out' get method\n  real_T ClusterControl::getRPM_Out() const\n  {\n    return ClusterControl_Y.RPM_Out;\n  }\n\n  // Constructor\n  ClusterControl::ClusterControl() :\n    ClusterControl_U(),\n    ClusterControl_Y(),\n    ClusterControl_B(),\n    ClusterControl_DW(),\n    ClusterControl_M()\n  {\n    // Currently there is no constructor body generated.\n  }\n\n  // Destructor\n  ClusterControl::~ClusterControl()\n  {\n    // Currently there is no destructor body generated.\n  }\n\n  // Real-Time Model get method\n  ClusterControl::RT_MODEL_ClusterControl_T * ClusterControl::getRTM()\n  {\n    return (&ClusterControl_M);\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_h_\n#define RTW_HEADER_ClusterControl_h_\n#include \"rtwtypes.h\"\n#include \"ClusterControl_types.h\"\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n// Code_Instrumentation_Declarations_Placeholder\n\n// Class declaration for model ClusterControl\nnamespace BenchTest\n{\n  class ClusterControl\n  {\n    // public data and function members\n   public:\n    // Block signals (default storage)\n    struct B_ClusterControl_T {\n      real_T Velocity;                 // '<S5>/X''\n      real_T Cx;                       // '<S5>/Cx''\n      real_T Kx;                       // '<S5>/Kx'\n      real_T Cu;                       // '<S5>/Cu''\n      real_T Ku;                       // '<S5>/Ku'\n      real_T Add;                      // '<S5>/Add'\n      real_T Acceleration;             // '<S5>/Divide'\n      int32_T TSamp;                   // '<S6>/TSamp'\n      int32_T Uk1;                     // '<S6>/UD'\n      int32_T Diff;                    // '<S6>/Diff'\n    };\n\n    // Block states (default storage) for system '<Root>'\n    struct DW_ClusterControl_T {\n      real_T X_DSTATE;                 // '<S5>/X''\n      real_T X_DSTATE_c;               // '<S5>/X'\n      int32_T UD_DSTATE;               // '<S6>/UD'\n      int32_T Diff_DWORK1;             // '<S6>/Diff'\n    };\n\n    // External inputs (root inport signals with default storage)\n    struct ExtU_ClusterControl_T {\n      int32_T RPM_In;                  // '<Root>/RPM_In'\n    };\n\n    // External outputs (root outports fed by signals with default storage)\n    struct ExtY_ClusterControl_T {\n      real_T RPM_Out;                  // '<Root>/RPM_Out'\n    };\n\n    // Parameters (default storage)\n    struct P_ClusterControl_T {\n      int32_T DiscreteDerivative_ICPrevScaled;\n                              // Mask Parameter: DiscreteDerivative_ICPrevScaled\n                                 //  Referenced by: '<S6>/UD'\n\n      real_T X_gainval;                // Computed Parameter: X_gainval\n                                          //  Referenced by: '<S5>/X''\n\n      real_T X_IC;                     // Expression: 0\n                                          //  Referenced by: '<S5>/X''\n\n      real_T C_Value;                  // Expression: 4\n                                          //  Referenced by: '<S5>/C'\n\n      real_T X_gainval_k;              // Computed Parameter: X_gainval_k\n                                          //  Referenced by: '<S5>/X'\n\n      real_T X_IC_g;                   // Expression: 0\n                                          //  Referenced by: '<S5>/X'\n\n      real_T K_Value;                  // Expression: 15\n                                          //  Referenced by: '<S5>/K'\n\n      real_T m_Value;                  // Expression: 0.2\n                                          //  Referenced by: '<S5>/m'\n\n    };\n\n    // Real-time Model Data Structure\n    struct RT_MODEL_ClusterControl_T {\n      const char_T * volatile errorStatus;\n    };\n\n    // Real-Time Model get method\n    ClusterControl::RT_MODEL_ClusterControl_T * getRTM();\n\n    // External inputs\n    ExtU_ClusterControl_T ClusterControl_U;\n\n    // External outputs\n    ExtY_ClusterControl_T ClusterControl_Y;\n\n    // Tunable parameters\n    static P_ClusterControl_T ClusterControl_P;\n\n    // Root inport: '<Root>/RPM_In' set method\n    void setRPM_In(int32_T localArgInput);\n\n    // Root outport: '<Root>/RPM_Out' get method\n    real_T getRPM_Out() const;\n\n    // model initialize function\n    void Initialize();\n\n    // model step function\n    void Model_Step_100Hz();\n\n    // model terminate function\n    static void Terminate();\n\n    // Constructor\n    ClusterControl();\n\n    // Destructor\n    ~ClusterControl();\n\n    // private data and function members\n   private:\n    // Block signals\n    B_ClusterControl_T ClusterControl_B;\n\n    // Block states\n    DW_ClusterControl_T ClusterControl_DW;\n\n    // private member function(s) for subsystem '<Root>/Model_Step10'\n    void Model_Step_10Hz();\n\n    // Real-Time Model\n    RT_MODEL_ClusterControl_T ClusterControl_M;\n  };\n}\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S6>/Data Type Duplicate' : Unused code path elimination\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'ClusterControl'\n//  '<S1>'   : 'ClusterControl/Initialize Function'\n//  '<S2>'   : 'ClusterControl/Model_Step10'\n//  '<S3>'   : 'ClusterControl/Model_Step100'\n//  '<S4>'   : 'ClusterControl/Terminate Function'\n//  '<S5>'   : 'ClusterControl/Model_Step100/SDOF'\n//  '<S6>'   : 'ClusterControl/Model_Step100/SDOF/Discrete Derivative'\n\n#endif                                 // RTW_HEADER_ClusterControl_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_private.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_private.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_private_h_\n#define RTW_HEADER_ClusterControl_private_h_\n#include \"rtwtypes.h\"\n#include \"ClusterControl_types.h\"\n#ifndef UCHAR_MAX\n#include <limits.h>\n#endif\n\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\n#error Code was generated for compiler with different sized uchar/char. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\n#error Code was generated for compiler with different sized ushort/short. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized uint/int. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n// Skipping ulong/long check: insufficient preprocessor integer range.\n\n// Skipping ulong_long/long_long check: insufficient preprocessor integer range. \n#endif                                 // RTW_HEADER_ClusterControl_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_types.h","type":"header","group":"model","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_types.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_ClusterControl_types_h_\n#define RTW_HEADER_ClusterControl_types_h_\n#endif                                 // RTW_HEADER_ClusterControl_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ClusterControl_data.cpp","type":"source","group":"data","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/ClusterControl_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: ClusterControl_data.cpp\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.12\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Fri Sep 15 22:06:10 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"ClusterControl.h\"\n\n// Block parameters (default storage)\nBenchTest::ClusterControl::P_ClusterControl_T BenchTest::ClusterControl::\n  ClusterControl_P = {\n  // Mask Parameter: DiscreteDerivative_ICPrevScaled\n  //  Referenced by: '<S6>/UD'\n\n  0,\n\n  // Computed Parameter: X_gainval\n  //  Referenced by: '<S5>/X''\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S5>/X''\n\n  0.0,\n\n  // Expression: 4\n  //  Referenced by: '<S5>/C'\n\n  4.0,\n\n  // Computed Parameter: X_gainval_k\n  //  Referenced by: '<S5>/X'\n\n  0.01,\n\n  // Expression: 0\n  //  Referenced by: '<S5>/X'\n\n  0.0,\n\n  // Expression: 15\n  //  Referenced by: '<S5>/K'\n\n  15.0,\n\n  // Expression: 0.2\n  //  Referenced by: '<S5>/m'\n\n  0.2\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"/Users/joel/GitHub/PiGUIAuto/PiGUIAuto/MATLAB/ClusterControl/slprj/ert/_sharedutils","tag":"","groupDisplay":"Shared files","code":"//\n// Prerelease License - for engineering feedback and testing purposes\n// only. Not for sale.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'ClusterControl'.\n//\n// Model version                  : 1.1\n// Simulink Coder version         : 23.2 (R2023b) 19-May-2023\n// C/C++ source code generated on : Tue Aug 22 21:10:09 2023\n//\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: ARM Compatible->ARM Cortex-A (64-bit)\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  64    long long:  64\n//                        native word size:  64\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};